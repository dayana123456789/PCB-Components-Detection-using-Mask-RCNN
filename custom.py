# -*- coding: utf-8 -*-
"""mrcnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MXaRoOY3RZMlr5qUIXQ2X3hC_4CzBeky

Required Packages for Mask RCNN Tensorflow 2
"""

import os #just another way to navIgate through folders - using python
os.chdir('C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB')

from tensorflow.compat.v1 import ConfigProto
from tensorflow.compat.v1 import InteractiveSession
config = ConfigProto()
config.gpu_options.allow_growth = True
session = InteractiveSession(config=config)

# Commented out IPython magic to ensure Python compatibility.
import sys
import random
import math
import numpy as np
import skimage.io
import matplotlib
import matplotlib.pyplot as plt
import cv2
import imgaug.augmenters as iaa

# Root directory of the project
ROOT_DIR = 'C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB'

# Import Mask RCNN
sys.path.append(ROOT_DIR)  # To find local version of the library
from mrcnn import utils
from mrcnn import visualize
import mrcnn.model as modellib
from mrcnn.config import Config



# %matplotlib inline

# Directory to save logs and trained model
MODEL_DIR = os.path.join(ROOT_DIR, "logs")

# Local path to trained weights file
COCO_MODEL_PATH = os.path.join(ROOT_DIR, "mask_rcnn_coco.h5")
# Download COCO trained weights from Releases if needed
if not os.path.exists(COCO_MODEL_PATH):
    utils.download_trained_weights(COCO_MODEL_PATH)

# Directory of images to run detection on

IMAGE_DIR_TRAIN = os.path.join(ROOT_DIR, "dataset_crt/train")

import os
import json
import skimage.io
import numpy as np
from mrcnn import utils
from mrcnn.config import Config
from mrcnn import model as modellib
from mrcnn import visualize

class CustomConfig(Config):
    """Configuration for training on the custom  dataset.
    Derives from the base Config class and overrides some values.
    """
    # Give the configuration a recognizable name
    NAME = "object"

    # We use a GPU with 24GB memory, which can fit 4 images.
    # Adjust down if you use a smaller GPU.
    IMAGES_PER_GPU = 1

    # Number of classes (including background)
    NUM_CLASSES = 1 + 4  # Background + Connector +Capacitor + Transistor +IC
    BACKBONE = 'resnet101'
    USE_MINI_MASK = False
    # Number of training steps per epoch
    STEPS_PER_EPOCH =10

    # Skip detections with < 90% confidence
    DETECTION_MIN_CONFIDENCE = 0.9
    # Learning Rate
    LEARNING_RATE = 0.01
    WEIGHT_DECAY = 0.0001
    LEARNING_MOMENTUM = 0.9




############################################################
#  Dataset
############################################################

class CustomDataset(utils.Dataset):

    def load_custom(self, dataset_dir, subset):


        # Add classes. We have only one class to add.
        self.add_class("object", 1, "Connector")
        self.add_class("object", 2, "Capacitor")
        self.add_class("object", 3, "Transistor")
        self.add_class("object", 4, "IC")


        if subset == "train":
            annotations_path = os.path.join(dataset_dir, "train", "via_region_data.json")
        elif subset == "val":
            annotations_path = os.path.join(dataset_dir, "val", "via_region_data.json")

        annotations = json.load(open(annotations_path))
        annotations = list(annotations.values())

        # The VIA tool saves images in the JSON even if they don't have any
        # annotations. Skip unannotated images.
        annotations = [a for a in annotations if a['regions']]

        # Add images
        for a in annotations:
            # print(a)
            # Get the x, y coordinaets of points of the polygons that make up
            # the outline of each object instance. There are stores in the
            # shape_attributes (see json format above)
            polygons = [r['shape_attributes'] for r in a['regions']]
            objects = [s['region_attributes']['names'] for s in a['regions']]
            name_dict = {"Connector": 1,"Capacitor":2,"Transistor":3,"IC":4}
            # key = tuple(name_dict)
            num_ids = [name_dict[a] for a in objects]

            # num_ids = [int(n['Event']) for n in objects]
            # load_mask() needs the image size to convert polygons to masks.
            # Unfortunately, VIA doesn't include it in JSON, so we must read
            # the image. This is only managable since the dataset is tiny.
            image_path = os.path.join(dataset_dir, subset, a['filename'])
            image = skimage.io.imread(image_path)
            height, width = image.shape[:2]
            self.add_image(
                "object",  ## for a single class just add the name here
                image_id=a['filename'],  # use file name as a unique image id
                path=image_path,
                width=width, height=height,
                polygons=polygons,
                num_ids=num_ids
                )

    def load_mask(self, image_id):
        """Generate instance masks for an image.
      Returns:
        masks: A bool array of shape [height, width, instance count] with
            one mask per instance.
        class_ids: a 1D array of class IDs of the instance masks.
        """
        # If not an "object" dataset image, delegate to the parent class.
        image_info = self.image_info[image_id]
        if image_info["source"] != "object":
            return super(self.__class__, self).load_mask(image_id)

        # Convert polygons to a bitmap mask of shape
        # [height, width, instance_count]
        info = self.image_info[image_id]
        mask = np.zeros([info["height"], info["width"], len(info["polygons"])],
                        dtype=np.uint8)
        class_ids = np.zeros([len(info["polygons"])], dtype=np.int32)

        for i, p in enumerate(info["polygons"]):
            # Get indexes of pixels inside the polygon and set them to 1
            rr, cc = skimage.draw.polygon(p['all_points_y'], p['all_points_x'])

            # Clamp the indexes to stay within the image bounds
            rr[rr > mask.shape[0]-1] = mask.shape[0]-1
            cc[cc > mask.shape[1]-1] = mask.shape[1]-1

            mask[rr, cc, i] = 1

            # Assign class ID based on the num_ids field associated with the instance
            class_ids[i] = info['num_ids'][i]

        # Return mask and class IDs for each instance
        return mask.astype(bool), class_ids


    def image_reference(self, image_id):
        """Return the path of the image."""
        info = self.image_info[image_id]
        if info["source"] == "object":
            return info["path"]
        else:
            super(self.__class__, self).image_reference(image_id)
def train(model):
    """Train the model."""
    # Training dataset.
    dataset_train = CustomDataset()
    dataset_train.load_custom("C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB/dataset_crt", "train")
    dataset_train.prepare()

    # Validation dataset
    dataset_val = CustomDataset()
    dataset_val.load_custom("C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB/dataset_crt", "val")   
    dataset_val.prepare()
    # *** This training schedule is an example. Update to your needs ***
    # Since we're using a very small dataset, and starting from
    # COCO trained weights, we don't need to train too long. Also,
    # no need to train all layers, just the heads should do it.
    print("Training network heads")
    model.train(dataset_train, dataset_val,
                learning_rate=config.LEARNING_RATE,
                epochs=100,
                layers='heads',augmentation = iaa.Sometimes(5/6,iaa.OneOf([
            iaa.Fliplr(1),
            iaa.Flipud(1),
            iaa.Affine(rotate=(-45, 45)),
            iaa.Affine(rotate=(-90, 90)),
            iaa.Affine(scale=(0.5, 1.5))
            ])))
    history = model.keras_model.history.history


config = CustomConfig()
model = modellib.MaskRCNN(mode="training", config=config,
                                  model_dir="C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB/logs")

weights_path = "C:/Users/Dayana Vincent/Downloads/MASKRCNN_PCB/mask_rcnn_coco.h5"
        # Download weights file
if not os.path.exists(weights_path):
  utils.download_trained_weights(weights_path)

model.load_weights(weights_path, by_name=True, exclude=[
            "mrcnn_class_logits", "mrcnn_bbox_fc",
            "mrcnn_bbox", "mrcnn_mask"])

train(model)